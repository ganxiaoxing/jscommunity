- Even Loop
  
- 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。
  
- vue 具名插槽

  ```js
   <slot name="header"></slot> //子组件具名
  
    <template v-slot:header>
      <h1>Here might be a page title</h1>
    </template>//插槽
  
  ```

  ```
  注意 v-slot 只能添加在 <template> 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。
  ```

- 作用于插槽

- ```
Url输入到页面显示经历了什么？「导航阶段 dns解析 tcp连接 TLS验证 发起请求 接收响应 连接中断。解析阶段 html js css分开解析，html解析为dom对象，拆分标签 text，js由v8引擎处理，css被解析为cssom 层树，光栅化」
  ```
  
- ```
  Promise是属于微任务吗？「不 promise.then属于微任务」
  ```

- ```
  Webpack有用过吗？做过哪些配置？「不同环境的配置，devserver」有哪些优化措施？「tree shaking，路由懒加载，代码分割」
  ```

- ```
  koa「基于express的一个node框架，本质非常简单，把其他应用都作为中间件外包出去，核心是洋葱圈模型」  koa是基于express的
  ```

- vue路由过渡动画

  ```css
  .fade-enter {
    opacity:0;
  }
  .fade-leave{
    opacity:1;
  }
  .fade-enter-active{
    transition:opacity .9s;
  }
  .fade-leave-active{
    opacity:0;
    
  }
  ```

  

- CSS选择后4项   

  ```css
   .floor-item-image {
              image {
                  &:nth-last-child(-n+4) {
  
                      height: 33.33vw * 386/232/2;
                      border-left: 10rpx solid white;
                  }
  
                  &:nth-last-child(-n+2) {
  
  
                      border-top: 10rpx solid white;
                  }
  
                  float: left;
                  width: 33.33%;
                  border-radius: 10rpx;
  
              }
  
  
          }
  ```

  

- css设置文字居中

  ```css
              line-height: 90rpx;
              text-align: center;
  ```

   style="{{item.cat_id==onClick?'background-color: #FFFFFF':'background-color: #F4F4F4;'}}"

- css公式选择器

  ```
  使用公式 (an + b)。描述：表示周期的长度，n 是计数器（从 0 开始），b 是偏移值。
  
  在这里，我们指定了下标是 3 的倍数的所有 p 元素的背景色：
  
  p:nth-child(3n+0)
  {
  background:#ff0000;
  }
  ```


- 事件捕获，目标，冒泡

  ``` 
  在所有的现代浏览器当中——除了IE9之前的版本——都实现了DOM2标准事件模型，即事件处理过程的三个阶段：捕获，目标，冒泡；
  
  （1）捕获阶段：当我们在 DOM 树的某个节点发生了一些操作（例如单击、鼠标移动上去），就会有一个事件发射过去。这个事件从 Window 发出，不断经过下级节点直到触发的目标节点。在到达目标节点之前的过程，就是捕获阶段（Capture Phase）。（所有经过的节点，都会触发这个事件。捕获阶段的任务就是建立这个事件传递路线，以便后面冒泡阶段顺着这条路线返回 Window。）在目标元素对象本身上注册的捕获事件处理程序不会被调用。
  （2）目标阶段：当事件不断的传递直到目标节点的时候，最终在目标节点上触发这个事件，就是目标阶段。
  （3）冒泡阶段：事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点（我们平时用的事件绑定就是利用的事件冒泡的原理）
  事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。
  
  事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件
  
  事件一开始从文档的根节点流向目标对象（捕获阶段），然后在目标对向上被触发（目标阶段），之后再回溯到文档的根节点（冒泡阶段）。
  
  事件冒泡过程，是可以被阻止的。防止事件冒泡而带来不必要的错误和困扰。
  
  这个方法就是:stopPropagation()
  ```

- flex布局

  - ### justify-content

    ```
    flex-start（默认值）：左对齐
    flex-end：右对齐
    center： 居中
    space-between：两端对齐，项目之间的间隔都相等。
    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔
    大一倍。
    ```


- vuex

  ```js
  //引入store
  const store = new Vuex.Store({
    state: {
      count: 0
    },
    mutations: {
      increment (state) {
        state.count++
      },
      incrementN (state,step) {
        state.count+=step
      }
    },
    actions: {
      actionIncrement (context){
        setTimeout(()=>{
          context.commit('increment')
        },1000)
      },
      actionIncrementN (context,step){
        setTimeout(()=>{
          context.commit('incrementN',step)
        },1000)
      },
    },
     getters: {
      doneTodos: state => {
        return `剩余量为${count}`
      }
    }
  })
  ```

  - state

    ```js
    //组件第一种访问state
    this.$store.state
    
    //组件第二种fangwenstate
    import { mapState } from 'vuex'
    //映射为计算属性，可以直接用
    computed:{
        ...mapState(['count'])
    }
    ```

  - mutation

    ```js
    //组件访问mutation第一种方式
    this.$store.commit('increment')
    this.$store.commit('incrementN',5)
    
    //组件访问mutation第二种方式
    import { mapMutations } from 'vuex'
    //映射为组件内方法，可以直接调用
    methods:{
        ...mapMutations(['increment','incrementN'])
    }
    ```

  - action

    > **mutation只对state进行数据修改，不建议进行业务操作，如果要进行业务操作或者对state的异步操作，就利用action先写业务逻辑，在调用mutation对state进行修改**

    ```js
    //组件访问action第一种方式,第二个参数可传参
    this.$store.dispatch('actionIncrement')
    this.$store.dispatch('actionIncrementN',5)
    
    //组件内访问action第二种方式
    import{ mapActions } from 'vuex'
    //映射为组件内方法，可以直接调用
    methods:{
        ...mapActions(['actionIncrement','actionIncrementN'])
    }
    ```

  - getter

    > geter用于对store.state的数据进行加工处理成新的数据，在组件内一样映射为computed属性

    ```js
    //组件内访问getter内的数据的第一种方式
    this.$store.getters.doneTodos
    
    //组件内访问getter内的数据的第一种方式
    import{ mapGetters } from 'vuex'
    //在组件内映射为计算属性使用
    computed:{
        ...mapGetters(['doneTodos'])
    }
    ```


- #### 简述TCP建立连接和释放连接

> 第一次握手：客户端将同步号SYN置为1，随机产生一个值seq=x，将该数据包发送给服务端，客户端进入SYN_SENT状态，等待服务端确认。
> 第二次握手：服务端收到数据包后由同步号SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入SYN_RCVD状态。
> 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端，服务端检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务端进入ESTABLISHED状态.
> 完成三次握手,成功建立链接，进行数据传输。



#### 你所知道的前端性能优化方案

这个其实方案还是比较多的，可以从**DOM层面**，**CSS样式层面**和**JS逻辑层面**分别入手，大概给出以下几种：
 (1) 减少DOM的访问次数，可以将DOM缓存到变量中；
 (2) 减少**重绘**和**回流**，任何会导致**重绘**和**回流**的操作都应减少执行，可将**多次操作合并为一次**；
 (3) 尽量采用**事件委托**的方式进行事件绑定，避免大量绑定导致内存占用过多；
 (4) css层级尽量**扁平化**，避免过多的层级嵌套，尽量使用**特定的选择器**来区分；
 (5) 动画尽量使用CSS3**动画属性**来实现，开启GPU硬件加速；
 (6) 图片在加载前提前**指定宽高**或者**脱离文档流**，可避免加载后的重新计算导致的页面回流；
 (7) css文件在``标签中引入，js文件在``标签中引入，优化**关键渲染路径**；
 (8) 加速或者减少HTTP请求，使用**CDN加载静态资源**，合理使用浏览器**强缓存**和**协商缓存**，小图片可以使用**Base64**来代替，合理使用浏览器的**预取指令prefetch**和**预加载指令preload**；
 (9) **压缩混淆代码**，**删除无用代码**，**代码拆分**来减少文件体积；
 (10) **小图片使用雪碧图**，图片选择合适的**质量**、**尺寸**和**格式**，避免流量浪费。



####  CSS3中transition和animation的属性分别有哪些

`transition` 过渡动画：
 (1) `transition-property`：属性名称
 (2) `transition-duration`: 间隔时间
 (3) `transition-timing-function`: 动画曲线
 (4) `transition-delay`: 延迟

`animation` 关键帧动画：
 (1) `animation-name`：动画名称
 (2) `animation-duration`: 间隔时间
 (3) `animation-timing-function`: 动画曲线
 (4) `animation-delay`: 延迟
 (5) `animation-iteration-count`：动画次数
 (6) `animation-direction`: 方向
 (7) `animation-fill-mode`: 禁止模式

- **indexOf 和 lastIndexOf 是什么？**
- 　　indexOf 和 lastIndexOf 都是索引文件
- 　　indexOf 是查某个指定的字符串在字符串首次出现的位置（索引值）（从左往右）
- ​    lastIndexOf 是查某个指定的字符串在字符串最后一次出现的位置（索引值）（从右往左）

### 数组删除方法

**delete关键字**

JavaScript提供了一个delete关键字用来删除（清除）数组元素。

```
var` `colors = [``"red"``, ``"blue"``, ``"grey"``, ``"green"``];``delete` `colors[0];` `console.log(arr); ``// [undefined, "blue", "grey", "green"]
```

要注意的是，使用delete删除元素之后数组长度不变，只是被删除元素被置为undefined了。

**pop()栈方法**

JavaScript中的Array对象提供了一个pop()栈方法用于弹出并返回数组中的最后一项，某种程度上可以当做删除用。

栈数据结构的访问规则是FILO（First In Last Out，先进后出），栈操作在栈顶添加项，从栈顶移除项，使用pop()方法，它能移除数组中的最后一项并返回该项，并且数组的长度减1。

```
var` `colors = [``"red"``, ``"blue"``, ``"grey"``];``var` `color = colors.pop();` `console.log(color); ``// "grey"``console.log(colors.length); ``// 2
```

可以看出，在调用pop()方法时，数组返回最后一项，即”grey”，数组的元素也仅剩两项。

**shift()队列方法**

JavaScript中的Array对象提供了一个shift()队列方法用于弹出并返回数组中的第一项，某种程度上也可以当做删除用。

队列数据结构的访问规则是FIFO（First In First Out，先进先出），队列在列表的末端添加项，从列表的前端移除项，使用shift()方法，它能够移除数组中的第一个项并返回该项，并且数组的长度减1。

```
var` `colors = [``"red"``, ``"blue"``, ``"grey"``];``var` `color = colors.shift();` `console.log(color); ``// "red"``console.log(colors.length); ``// 2
```

可以看出，在调用shift()方法时，数组返回第一项，即”red”，数组的元素也仅剩两项。

**splice()操作方法**

在JavaScript的Array对象中提供了一个splice()方法用于对数组进行特定的操作。splice()恐怕要算最强大的数组方法了，他的用法有很多种，在此只介绍删除数组元素的方法。在删除数组元素的时候，它可以删除任意数量的项，只需要指定2个参数：要删除的第一项的位置和要删除的项数。

```
var` `colors = [``"red"``, ``"blue"``, ``"grey"``];``var` `color = colors.splice(0, 1);` `console.log(color); ``// "red"``console.log(colors); ``// ["blue", "grey"]
```

可以看出，在调用了splice(0, 1)方法时，数组从第一项开始，删除了一项。